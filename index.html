<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>円形メトロノーム</title>
  <style>
    body {
      background: #111;
      color: #fff;
      font-family: sans-serif;
      text-align: center;
      padding: 2rem;
    }

    canvas {
      background: #222;
      border-radius: 50%;
      display: block;
      margin: 1rem auto;
    }

    #controls {
      margin-top: 1rem;
    }

    button {
      font-size: 1rem;
      padding: 0.5rem 1rem;
      margin: 0.5rem;
    }

    input[type="number"] {
      width: 4rem;
    }
  </style>
</head>
<body>
  <h1>円形メトロノーム</h1>
  <canvas id="metronomeCanvas" width="300" height="300"></canvas>
  <div id="controls">
    BPM: <input type="number" id="bpmInput" value="120" min="30" max="300">
    <button id="startStopBtn">Start</button>
  </div>

  <script>
    const canvas = document.getElementById('metronomeCanvas');
    const ctx = canvas.getContext('2d');
    const bpmInput = document.getElementById('bpmInput');
    const startStopBtn = document.getElementById('startStopBtn');

    let isRunning = false;
    let currentStep = 0;
    const totalSteps = 16;
    let intervalId;

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // 👇 iOS Safari 対応：最初のタッチで AudioContext を resume
    document.body.addEventListener("touchstart", () => {
      if (audioCtx.state === "suspended") {
        audioCtx.resume();
      }
    }, { once: true });

    function playClick() {
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.type = "square";
      osc.frequency.value = 1000;
      gain.gain.setValueAtTime(1, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
      osc.connect(gain);
      gain.connect(audioCtx.destination);
      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.1);
    }

    function drawCircle(step) {
      const radius = 120;
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.stroke();

      for (let i = 0; i < totalSteps; i++) {
        const angle = (i / totalSteps) * 2 * Math.PI;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);
        ctx.beginPath();
        ctx.arc(x, y, 8, 0, 2 * Math.PI);
        ctx.fillStyle = i === step ? '#f00' : '#666';
        ctx.fill();
      }
    }

    function updateMetronome() {
      drawCircle(currentStep);
      playClick();
      currentStep = (currentStep + 1) % totalSteps;
    }

    startStopBtn.onclick = async () => {
      if (audioCtx.state === "suspended") {
        await audioCtx.resume();
      }

      if (isRunning) {
        clearInterval(intervalId);
        startStopBtn.textContent = "Start";
      } else {
        currentStep = 0;
        const bpm = parseInt(bpmInput.value, 10);
        const interval = (60 / bpm) * 1000 / 4;
        updateMetronome();
        intervalId = setInterval(updateMetronome, interval);
        startStopBtn.textContent = "Stop";
      }

      isRunning = !isRunning;
    };

    drawCircle(-1);
  </script>
</body>
</html>
