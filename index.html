<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>拡張メトロノーム（10セクション＋プリカウント＋拍ベース進行）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { background:#111; color:#fff; font-family:sans-serif; padding:2rem; display:flex; flex-direction:column; align-items:center; justify-content:flex-start; min-height:100vh; box-sizing:border-box; }
    canvas { background:#222; border-radius:50%; margin-top:1rem; box-shadow:0 0 12px #000; }
    .controls { display:flex; flex-direction:column; gap:1rem; min-width:320px; margin-top:2rem; align-items:center; }
    .bpm-controls { display:flex; align-items:center; gap:0.5rem; margin-bottom:1rem; justify-content:center; }
    .bpm-controls button { width:2rem; height:2rem; cursor:pointer; background:#444; border:none; border-radius:4px; color:#eee; font-weight:bold; font-size:1.2rem; transition:background 0.3s; }
    .bpm-controls button:hover { background:#ffaa00; color:#111; }
    .bpm-controls label { font-weight:bold; user-select:none; }
    .section-control { display:flex; flex-direction:column; gap:0.35rem; background:#222; padding:0.5rem 0.6rem; border-radius:6px; width:100%; }
    .section-control > div { display:flex; align-items:center; gap:0.35rem; white-space:nowrap; flex-wrap:nowrap; overflow:hidden; }
    .section-btn { min-width:90px; cursor:pointer; background:#444; border:none; color:#eee; border-radius:4px; font-weight:bold; transition:background 0.3s; user-select:none; padding:0.3rem 0.6rem; }
    .section-btn.selected, .section-btn:hover { background:#ffaa00; color:#111; }
    label { white-space:nowrap; user-select:none; font-size:0.92rem; }
    select { background:#333; border:none; color:#eee; border-radius:4px; padding:0.18rem 0.4rem; font-size:0.9rem; min-width:100px; cursor:pointer; transition:background 0.3s; }
    select:hover { background:#555; }
    /* 小節数だけさらにスリム化 */
    .measure-select { min-width:64px; }
    #startStop { margin-top:1rem; cursor:pointer; font-weight:bold; font-size:1rem; padding:0.5rem 1rem; border-radius:6px; background:#444; border:none; color:#eee; transition:background 0.3s; }
    #startStop:hover { background:#ffaa00; color:#111; }

    /* iPhone など狭幅向け微調整 */
    @media (max-width: 430px) {
      .controls { min-width: 300px; }
      .section-control > div { gap:0.25rem; }
      label { font-size:0.88rem; }
      select { font-size:0.86rem; padding:0.14rem 0.35rem; min-width:96px; }
      .measure-select { min-width:56px; }
      .section-btn { min-width:80px; padding:0.25rem 0.5rem; }
    }
  </style>
</head>
<body>
  <canvas id="metronome" width="400" height="400"></canvas>
  <div class="controls">
    <div class="bpm-controls">
      <label for="bpm-value">BPM:</label>
      <button id="bpm-down">−</button>
      <span id="bpm-value">60</span>
      <button id="bpm-up">＋</button>
    </div>
    <div id="section-wrapper"></div>
    <button id="startStop">スタート</button>
  </div>
  <script>
    const canvas = document.getElementById("metronome");
    const ctx = canvas.getContext("2d");
    const bpmUpBtn = document.getElementById("bpm-up");
    const bpmDownBtn = document.getElementById("bpm-down");
    const bpmValue = document.getElementById("bpm-value");
    const startStopBtn = document.getElementById("startStop");
    const sectionWrapper = document.getElementById("section-wrapper");

    let audioCtx = null, running = false, angle = -Math.PI / 2, lastTime = 0;
    let bpm = 60, rotationSpeed = 2 * Math.PI * bpm / 60;
    let currentSetIndex = 0, triggerAngles = [], secondTriggerAngles = [];
    let clickCount = 0; // 併用可（念のため残置）
    let beatCount = 0;  // ★ 小節進行は“拍”で判定（1周=1拍）

    // プリカウント制御（4分音符×2小節=8拍）
    let isPrecount = false;
    const PRECOUNT_BEATS = 8;
    let precountDone = 0;

    // 主/第2リズム分割（1..8 / 0..8）
    // 1:4分, 2:8分, 3:3連, 4:16分, 5:5連, 6:6連, 7:7連, 8:32分
    let subdivision = 2;
    let secondSubdivision = 0;

    const MAIN_RHYTHM_OPTIONS = [
      { label: "4分音符", value: 1 },
      { label: "8分音符", value: 2 },
      { label: "3連符",   value: 3 },
      { label: "16分音符", value: 4 },
      { label: "5連符",   value: 5 },
      { label: "6連符",   value: 6 },
      { label: "7連符",   value: 7 },
      { label: "32分音符", value: 8 },
    ];
    const SECOND_RHYTHM_OPTIONS = [
      { label: "なし", value: 0 },
      ...MAIN_RHYTHM_OPTIONS
    ];

    // ★ デフォルト（10セクション）
    // 主: Ⅰ→Ⅹ = [4分,8分,3連,16分,6連,32分,6連,16分,3連,8分]
    // 小節=2 / 第2=8分
    const DEFAULT_MAIN = [1, 2, 3, 4, 6, 8, 6, 4, 3, 2];
    const DEFAULT_MEASURES = 2;
    const DEFAULT_SECOND = 2; // 8分

    let settingsSequence = Array.from({ length: 10 }, (_, i) => ({
      subdivision: DEFAULT_MAIN[i],
      secondSubdivision: DEFAULT_SECOND,
      measures: DEFAULT_MEASURES
    }));

    function createSectionUI() {
      sectionWrapper.innerHTML = "";
      const romans = "ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ";
      settingsSequence.forEach((s, i) => {
        const sc = document.createElement("div");
        sc.className = "section-control";
        const roman = romans[i];

        const measureOptions = [...Array(9).keys()].map(n =>
          `<option value="${n}"${n === s.measures ? " selected" : ""}>${n}</option>`
        ).join("");

        const mainOptions = MAIN_RHYTHM_OPTIONS.map(opt =>
          `<option value="${opt.value}"${opt.value === s.subdivision ? " selected" : ""}>${opt.label}</option>`
        ).join("");

        const secondOptions = SECOND_RHYTHM_OPTIONS.map(opt =>
          `<option value="${opt.value}"${opt.value === s.secondSubdivision ? " selected" : ""}>${opt.label}</option>`
        ).join("");

        sc.innerHTML = `
          <button class="section-btn">${roman} セクション</button>
          <div>
            <label>小節:
              <select class="measure-select">${measureOptions}</select>
            </label>
            <label>リズム:
              <select class="subdivision-select">${mainOptions}</select>
            </label>
            <label>第2:
              <select class="second-subdivision-select">${secondOptions}</select>
            </label>
          </div>`;
        sectionWrapper.appendChild(sc);
      });
    }

    function updateUIForSet(i) {
      document.querySelectorAll(".section-btn").forEach(b => b.classList.remove("selected"));
      const btn = document.querySelectorAll(".section-btn")[i];
      if (btn) btn.classList.add("selected");
    }

    function buildTriggers(divisions) {
      if (divisions <= 0) return [];
      return Array.from({ length: divisions }, (_, j) => ({
        angle: 2 * Math.PI * (j / divisions) - Math.PI / 2,
        triggered: false
      }));
    }

    function applySettings(i) {
      const s = settingsSequence[i];
      subdivision = Math.max(1, s.subdivision);              // 主リズムは最低1
      secondSubdivision = Math.max(0, s.secondSubdivision);  // 第2は0可
      rotationSpeed = 2 * Math.PI * bpm / 60;

      triggerAngles = buildTriggers(subdivision);
      secondTriggerAngles = secondSubdivision > 0 ? buildTriggers(secondSubdivision) : [];

      draw();
    }

    // プリカウント（4分音符）
    function applyPrecount() {
      rotationSpeed = 2 * Math.PI * bpm / 60;
      triggerAngles = buildTriggers(1);   // 4分
      secondTriggerAngles = [];           // プリカ中は第2なし
      draw();
    }

    // 第1リズムの音量は控えめ / 第2はやや強め
    function playClick(isAccent, isSecond = false) {
      if (!audioCtx) return;
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      osc.connect(gain); gain.connect(audioCtx.destination);
      osc.type = "sine";

      const freq = isSecond ? (isAccent ? 800 : 400) : (isAccent ? 1000 : 600);
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

      const peakGain = isSecond ? (isAccent ? 0.20 : 0.13) : (isAccent ? 0.12 : 0.08);
      gain.gain.setValueAtTime(peakGain, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.1);
    }

    function angleDiff(a, b) {
      return Math.abs(Math.atan2(Math.sin(a - b), Math.cos(a - b)));
    }

    function draw(flashIndex = -1, secondFlashIndex = -1) {
      const cx = canvas.width / 2, cy = canvas.height / 2, rOuter = 150, rInner = 115;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 第1リズム（外周）
      triggerAngles.forEach((t, i) => {
        const mx = cx + rOuter * Math.cos(t.angle), my = cy + rOuter * Math.sin(t.angle);
        ctx.beginPath(); ctx.arc(mx, my, 8, 0, 2 * Math.PI);
        ctx.fillStyle = (i === flashIndex ? "red" : "#ccbb33");
        ctx.shadowColor = (i === flashIndex ? "red" : "transparent");
        ctx.shadowBlur = (i === flashIndex ? 15 : 0);
        ctx.fill();
      });

      // 第2リズム（内周）
      secondTriggerAngles.forEach((t, i) => {
        const mx = cx + rInner * Math.cos(t.angle), my = cy + rInner * Math.sin(t.angle);
        ctx.beginPath(); ctx.arc(mx, my, 8, 0, 2 * Math.PI);
        ctx.fillStyle = (i === secondFlashIndex ? "#0ff" : "#088");
        ctx.shadowColor = (i === secondFlashIndex ? "#0ff" : "transparent");
        ctx.shadowBlur = (i === secondFlashIndex ? 10 : 0);
        ctx.fill();
        ctx.beginPath(); ctx.arc(mx, my, 2.5, 0, 2 * Math.PI);
        ctx.fillStyle = "#111"; ctx.fill();
      });

      // 外周ガイド
      ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, 2 * Math.PI);
      ctx.strokeStyle = "#444"; ctx.lineWidth = 3; ctx.stroke();

      // 現在位置ノード
      const px = cx + rOuter * Math.cos(angle), py = cy + rOuter * Math.sin(angle);
      ctx.beginPath(); ctx.arc(px, py, 10, 0, 2 * Math.PI);
      ctx.fillStyle = "yellow"; ctx.shadowColor = "yellow"; ctx.shadowBlur = 10; ctx.fill();

      // 中心点
      ctx.beginPath(); ctx.arc(cx, cy, 5, 0, 2 * Math.PI);
      ctx.fillStyle = "#fff"; ctx.fill();
    }

    function loop(time) {
      if (!running) return;
      const dt = (time - lastTime) / 1000; lastTime = time; angle += rotationSpeed * dt;

      if (angle > Math.PI) {
        angle -= 2 * Math.PI;
        triggerAngles.forEach(t => t.triggered = false);
        secondTriggerAngles.forEach(t => t.triggered = false);
      }

      let flashIndex = -1;

      // ===== プリカウント処理 =====
      if (isPrecount) {
        triggerAngles.forEach((t, i) => {
          if (angleDiff(angle, t.angle) < 0.08 && !t.triggered) {
            t.triggered = true;
            flashIndex = i;

            // 1拍目だけアクセント（各小節の頭=4拍ごと）
            const accent = (precountDone % 4 === 0);
            playClick(accent, false);

            precountDone++;
            if (precountDone >= PRECOUNT_BEATS) {
              // プリカウント終了 → Ⅰセクション開始
              isPrecount = false;
              precountDone = 0;
              clickCount = 0;
              beatCount = 0;          // ★ 拍カウントをリセット
              currentSetIndex = 0;
              while (settingsSequence[currentSetIndex].measures === 0)
                currentSetIndex = (currentSetIndex + 1) % settingsSequence.length;

              angle = -Math.PI / 2;   // 視覚位置を整える
              applySettings(currentSetIndex);
              updateUIForSet(currentSetIndex);
            }
          }
        });

        draw(flashIndex, -1);
        requestAnimationFrame(loop);
        return;
      }

      // ===== 通常セクション処理 =====
      triggerAngles.forEach((t, i) => {
        if (angleDiff(angle, t.angle) < 0.08 && !t.triggered) {
          t.triggered = true;
          flashIndex = i;
          playClick(i === 0); // 第1リズム（先頭でアクセント）

          // ★ 拍ベース進行：i===0（毎回転の先頭）でのみ拍を+1
          if (i === 0) {
            beatCount++;
            const totalBeats = settingsSequence[currentSetIndex].measures * 4; // 4/4
            if (totalBeats > 0 && beatCount >= totalBeats) {
              // 次セクションへ
              beatCount = 0;
              clickCount = 0;
              let nextIndex = currentSetIndex;
              do {
                nextIndex = (nextIndex + 1) % settingsSequence.length;
              } while (settingsSequence[nextIndex].measures === 0);
              currentSetIndex = nextIndex;

              angle = -Math.PI / 2;   // 視覚位置もリセット
              applySettings(currentSetIndex);
              updateUIForSet(currentSetIndex);
            }
          }
        }
      });

      let secondFlashIndex = -1;
      secondTriggerAngles.forEach((t, i) => {
        if (angleDiff(angle, t.angle) < 0.08 && !t.triggered) {
          t.triggered = true;
          secondFlashIndex = i;
          playClick(i === 0, true); // 第2リズム
        }
      });

      draw(flashIndex, secondFlashIndex);
      requestAnimationFrame(loop);
    }

    bpmUpBtn.onclick = () => { if (bpm < 300) bpm++; updateBPMDisplay(); };
    bpmDownBtn.onclick = () => { if (bpm > 20) bpm--; updateBPMDisplay(); };
    function updateBPMDisplay() { bpmValue.textContent = bpm; rotationSpeed = 2 * Math.PI * bpm / 60; }

    startStopBtn.onclick = async () => {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      running = !running; startStopBtn.textContent = running ? "ストップ" : "スタート";
      if (running) {
        lastTime = performance.now();
        angle = -Math.PI / 2;
        clickCount = 0;
        beatCount = 0;        // ★ 拍カウント初期化

        // プリカウント開始
        isPrecount = true;
        precountDone = 0;
        applyPrecount();              // 4分音符トリガー
        updateUIForSet(0);            // Ⅰセクションを強調（始まるのはプリカ後）
        requestAnimationFrame(loop);
      }
    };

    createSectionUI();

    // UIハンドラ
    document.querySelectorAll(".subdivision-select").forEach((sel, i) => sel.onchange = e => {
      settingsSequence[i].subdivision = parseInt(e.target.value, 10);  // 1..8
      if (!isPrecount && i === currentSetIndex) { beatCount = 0; angle = -Math.PI/2; applySettings(currentSetIndex); }
    });
    document.querySelectorAll(".second-subdivision-select").forEach((sel, i) => sel.onchange = e => {
      settingsSequence[i].secondSubdivision = parseInt(e.target.value, 10); // 0..8
      if (!isPrecount && i === currentSetIndex) { applySettings(currentSetIndex); }
    });
    document.querySelectorAll(".measure-select").forEach((sel, i) => sel.onchange = e => {
      settingsSequence[i].measures = parseInt(e.target.value, 10);
      if (!isPrecount && i === currentSetIndex) { beatCount = 0; }
    });
    document.querySelectorAll(".section-btn").forEach((btn, i) => btn.onclick = () => {
      // プリカ中に押されたら、プリカ後の開始セクションとして反映
      if (isPrecount) {
        currentSetIndex = i;
        updateUIForSet(currentSetIndex);
        return;
      }
      currentSetIndex = i;
      clickCount = 0;
      beatCount = 0;          // ★ 拍カウントもリセット
      angle = -Math.PI / 2;   // 視覚位置を合わせる
      applySettings(currentSetIndex);
      updateUIForSet(currentSetIndex);
    });

    // 初期描画
    applySettings(currentSetIndex); updateBPMDisplay(); draw();
  </script>
</body>
</html>
